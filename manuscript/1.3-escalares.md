# Deja atrás lo primitivo

> En el que se habla de que si estamos siguiendo un paradigma orientado a objetos, todo debería ser un objeto. Sí, todo.

### Notas de la segunda edición

Este capítulo necesitaba una fuerte reescritura, dado que estaba muy orientado a _Value Objects_, que es un concepto muy ligado a una metodología concreta de desarrollo. En general, encapsular comportamiento y datos en objetos es una buena idea, siempre y cuando representen algún tipo de concepto significativo.

Otro cambio destacable es que hemos incluído aquí el contenido correspondiente a los tipos _Enumerables_. Al revisar ese capítulo nos hemos dado cuenta de que en realidad el capítulo de _Enumerables_ estaba hablando del patrón _State_, que hemos movido a un capítulo dedicado.

## Está lleno de objetos

Todos los lenguajes de programación vienen de serie con un conjunto de tipos de datos básicos que denominamos primitivos. En algún caso también se les llama escalares, cuando el lenguaje no los implementa nativamente como objetos: _boolean_, _integer_, _float_ o _string_, entre otros, que utilizamos para representar cosas y operar con ellas. La parte mala es que se trata de tipos de datos muy genéricos y, a veces, necesitaríamos algo que aporte más significado y también más restricciones.

Los lenguajes orientados a objetos, en particular, ofrecen una estructura nativa de datos que permite encapsular primitivos y comportamiento en objetos. De este modo, podemos representar conceptos significativos en distintos dominios y niveles de abstracción. En algunos lenguajes también existe el tipo `Struct`, con el que podemos representar estructuras de datos simples, pero que no tienen comportamiento. Me voy a permitir hacer una clasificación de diversos tipos de objetos que podríamos tener en una aplicación:

* **Data Transfer Object (DTO)**: son objetos que se utilizan para transferir datos entre subsistemas de una aplicación. No tienen comportamiento y suelen ser muy simples, con propiedades públicas y sin métodos. Sus propiedades son tipos primitivos. Su ventaja es que son fáciles de serializar y deserializar. Por otro lado, podríamos incluir en esta categoría cualquier tipo de objeto que definimos con la única función de agrupar datos de forma arbitraria para mover información de un sitio a otro.
* **Tipos**: son objetos tienen la función de suplementar el sistema de tipos del lenguaje para añadir algunas restricciones y aportar significado a los datos. Imagina, por ejemplo, que quieres tener cosas como `NotEmptyString`, `PositiveNumber` y similares. Estos tipos no representan conceptos de un dominio específico, sino que son simplemente tipos de datos que añaden restricciones a los primitivos. Estos objetos tendrían un comportamiento fundamentalmente técnico y genérico.
* **Objetos**: en general, cualquier objeto que encapsula primitivos y comportamiento para representar algún concepto significativo del contexto en que se usa. La palabra dominio sería más correcta, pero está muy contaminada por el uso que se le da en DDD, por lo que prefiero evitarla. Por poner un ejemplo, la configuración de una base de datos podría representarse mediante un objeto `DatabaseConfiguration`, o un objeto `File` para representar un archivo en un sistema de almacenamiento, y un largo etcétera de casos. Pero, por supuesto, usaríamos objetos para representar conceptos de negocio, como `Customer`, `Product`, `Order`, etc.

En _Domain Driven Design_ se habla de _Value Objects_ y _Entities_. Ambos representan conceptos importantes del Dominio de Negocio de una aplicación. La principal diferencia es que los _Value Objects_ nos interesan por su valor y son inmutables, mientras que las _Entities_ nos interesan por su identidad y mutan a lo largo de su ciclo de vida.

### El problema de los tipos primitivos

**Validación.** Cuando queremos representar algún concepto en código inicialmente recurrimos a los tipos disponibles. Pensemos, por ejemplo, en un email, el cual usamos frecuentemente como nombre de usuario porque es único y fácil de recordar. Puesto que lo podemos representar con un tipo string, es habitual encontrarnos con código como este:

```php
$username = "user@example.com";
``` 

El problema es que un email no es un string cualquiera. Tiene una serie de restricciones que no se cumplen en un simple string. Por ejemplo, tiene que tener un formato concreto, con una longitud máxima, incluir el símbolo @, al menos un nombre de dominio, etc. Si queremos validar un email, tendremos que hacerlo manualmente. Esta sería una estrategia típica en PHP:

```php
function isValidEmail(string $email): bool
{
    return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;
}
```

En cualquier caso, como `$username` es una variable, sería fácil que en cualquier momento cambie. En consecuencia nunca vamos a poder tener la seguridad de que `$username` es un email válido fuera del _scope_ en que se haya validado, por lo que tenemos que repetir esa validación siempre.

**Conceptos compuestos**. Es muy frecuente que un concepto único se tenga que modelar con varios elementos. Así, por ejemplo, el nombre de una persona suele constar de nombre de pila y apellidos, para lo que podrían usarse dos strings:

```php
$firstName = "Pepa";
$lastName = "Pérez García";
```

El problema obvio es que tenemos que tener esto en cuenta constantemente y mover estas variables juntas a todas partes:

```php
function createFullName(string $firstName, string $lastName): string
{
    return $firstName . ' ' . $lastName;
}
```

Lo mismo ocurre aquí, que siempre tendremos que pasar ambos datos:

```php
class Customer
{
    private string $id;
    private string $name;
    private string $lastName;
    
    public function __construct(string $id, string $name, string $lastName) {
        $this->id = $id;
        $this->name = $name;
        $this->lastName = $lastName;
    }
}
```

La necesidad de mantener juntos un conjunto de datos da lugar a un _code smell_ llamado _Data Clump_. Este tipo de diseños son costosos de mantener y cambiar, ya que es fácil olvidar todos los elementos que tienen que mantenerse juntos y tenemos que hacer seguimiento de ellos en todos los rincones del código.

### Primitive Obsession

En último término, usar tipos primitivos para representar cualquier tipo de concepto provoca el _code smell_ llamado _Primitive Obsession_. Aunque en muchos contextos es perfectamente válido usar tipos primitivos, cuando estamos modelando un dominio complejo es preferible usar objetos. Los objetos nos permitirán resolver los problemas anteriores de una forma segura y elegante.

La resolución de _Primitive Obsession_ es, frecuentemente, _Replace Data with Object_, que es un refactor en el que encapsulamos el dato, o conjunto de datos, primitivo en un objeto simple.

```php
class Email
{
    private string $email;

    public function __construct(string $email)
    {
        $this->email = $email;
    }

    public function __toString(): string
    {
        return $this->email;
    }
}
```

Al principio vamos a tener muchas situaciones en las que querremos tener el equivalente primitivo del objeto, por lo que necesitaremos algún tipo de _getter_. Sin embargo, muchos lenguajes ofrecen la posibilidad de hacer un _type casting_ de un objeto a un primitivo, lo que nos permitirá usar el objeto en cualquier lugar donde se necesite el primitivo. Así, por ejemplo, en PHP se puede contar con el método mágico `__toString()` el cual es invocado automáticamente cuando hacemos el casting o bien en contextos en el que el dato esperado es un string.

```php
$email = new Email("fran.iglesias@example.com");

echo (string)$email;
```

En cualquier caso, una buena recomendación que podemos seguir es asegurar que estos métodos proporcionen una representación primitiva fácilmente parseable. Es decir, que teniendo el string que devuelve `__toString()` podamos reconstruir el objeto original.

### Ya tenemos el objeto, ¿qué ventajas obtenemos?

Así, por ejemplo, podemos hacer que un objeto se cree siempre con valores adecuados, impidiendo que se pueda instanciar si no se cumplen las condiciones requeridas. Veamos aquí el ejemplo con el email:

```php
class Email
{
    private string $email;

    public function __construct(string $email)
    {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new InvalidArgumentException('Invalid email address');
        }
        $this->email = $email;
    }

    public function __toString(): string
    {
        return $this->email;
    }
}
```

En consecuencia, si tenemos un objeto de tipo `Email` siempre tendremos la seguridad de que es válido, puesto que no se puede instanciar con valores que no pasen la validación. Además, si necesitamos el email como string, podemos hacer _type casting_ y obtenerlo. Entre otras ventajas, conseguimos reducir la cantidad de código repetitivo que necesitamos para validar los emails. Y en caso de que la validación cambie, solo tendremos que aplicar el cambio en un único lugar, garantizando la coherencia entre partes distintas de la aplicación.

Algunos autores, como Yegor Bugayenko, sostienen que este tipo de constructores con validación no son correctos. La razón es que el constructor debería ser lo más simple posible, y la validación debería hacerse en un método aparte. Entre otras razones, porque hay situaciones en las que podemos confiar en la validez de los parámetros de entrada. Su propuesta es utilizar constructores secundarios que, en el caso de PHP y otros lenguajes, se implementan como métodos de clase estáticos.

```php
class Email
{
    private string $email;

    private function __construct(string $email)
    {
        $this->email = $email;
    }

    public static function fromString(string $email): self
    {
        return new self($email);
    }

    public static function valid(string $email): self
    {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new InvalidArgumentException('Invalid email address');
        }
        return new self($email);
    }

    public function __toString(): string
    {
        return $this->email;
    }
}
```

### Resolviendo Data Clump

La solución a _Data Clump_, como hemos señalado arriba, es _Replace Data with Object_, encapsulando los datos en un objeto que represente el concepto que estamos modelando. Hay algunos contextos específicos en el que este _smell_ puede resolverse con _Introduce Parameter Object_, que es un refactor que consiste en agrupar los parámetros que pasamos a una función en objetos _ad hoc_. Vamos a aplicarlo al problema del nombre de una persona.

```php
$firstName = "Pepa";
$lastName = "Pérez García";
```

Podemos crear un objeto `SimpleName` que encapsule el nombre y el apellido:

```php
class SimpleName
{
    private string $name;
    private string $lastName;

    public function __construct(string $name, string $lastName)
    {
        $this->name = $name;
        $this->lastName = $lastName;
    }

    public function __toString(): string
    {
        return $this->name . ' ' . $this->lastName;
    }
}
```

Ahora podemos modificar la clase `Customer` para que use este objeto. Este es el objeto `Customer` que presentamos antes:

```php
class Customer
{
    private string $id;
    private string $name;
    private string $lastName;
    
    public function __construct(string $id, string $name, string $lastName) {
        $this->id = $id;
        $this->name = $name;
        $this->lastName = $lastName;
    }
}
```

Y este es el objeto `Customer` que usa `SimpleName`:

```php
class Customer
{
    private string $id;
    private SimpleName $personName;
    
    public function __construct(string $id, SimpleName $personName) {
        $this->id = $id;
        $this->personName = $personName;
    }
}
```

Ahora bien, hay muchos contextos en los que probablemente la información necesaria para inicializar `Customer` venga en forma de datos primitivos. ¿Deberíamos usar estos directamente o instanciar un `SimpleName` primero? Por supuesto, la respuesta es que depende. Una solución es introducir varios _Factory Method_ que permitan la creación de un objeto `Customer` de distintas formas, adecuadas para diferentes situaciones. En este ejemplo, exponemos dos: uno que recibe un nombre y un apellido y otro que recibe un objeto `SimpleName`.

```php
class Customer
{
    private string $id;
    private SimpleName $personName;
    
    private function __construct(string $id, SimpleName $personName) {
        $this->id = $id;
        $this->personName = $personName;
    }
    
    public static function fromName(string $id, string $name, string $lastName): self
    {
        $customer = new self($id, new SimpleName($name, $lastName));
        
        return $customer;
    }

    public static function fromSimpleName(string $id, SimpleName $personName): self
    {
        $customer = new self($id, '');
        $customer->personName = $personName;
        
        return $customer;
    }
}
```

El constructor nativo, primario o canónico, instancia `Customer` con datos ya encapsulados, que sería la forma canónica, y lo ponemos privado para que no se pueda usar directamente. En su lugar, usamos los métodos de clase `fromName` y `fromSimpleName` para crear instancias de `Customer`, según sea nuestro contexto.

## DTOs

Los DTO son objetos muy simples que no tienen comportamiento. Algunos lenguajes utilizan el tipo nativo `Struct` para representar este tipo de objetos. En otros, podemos usar clases con propiedades públicas, a ser posible de solo lectura, ya que deben ser inmutables. Estas propiedades serán de tipos primitivos del lenguaje, de este modo, la serialización y deserialización de los objetos será más sencilla.

```php
class CustomerDTO
{
    public readonly string $id;
    public readonly string $name;
    public readonly string $lastName;
    public readonly string $email;
}
```

Los DTO se utilizan para transferir datos entre subsistemas de una aplicación. Ni siquiera tendrían que ser una representación exacta de un concepto del dominio, sino que simplemente agrupan datos para moverlos de un sitio a otro. Por ejemplo, un DTO que represente los datos de un formulario que se envía a un servidor, o bien un DTO que represente los datos que se devuelven en una respuesta de una API.

Podemos usar DTO para modelar _Comandos_, _Queries_ y _Eventos_, ya que son mensajes que emite un subsistema o capa para que otro subsistema, o capa, los interprete y haga algo en respuesta. En general, los DTO son útiles para desacoplar subsistemas y capas, y permiten que los datos se muevan de un sitio a otro sin que los subsistemas tengan que conocerse entre sí.

```php
class CreateCustomerCommand
{
    public readonly string $id;
    public readonly string $name;
    public readonly string $lastName;
    public readonly string $email;
}
```

Un uso de los DTO sería resolver el problema de los _Data Clumps_ que mencionábamos antes. Si tenemos un conjunto de datos que se mueve siempre junto, podemos encapsularlos en un DTO y moverlos juntos. Por ejemplo, en el caso de una función que tenga muchos parámetros, podríamos reemplazarlos por un DTO.

```php
function createCustomer(string $id, string $name, string $lastName, string $email): void
{
    $customer = new Customer($id, $name, $lastName, $email);
    // ...
}
```

Algo parecido a esto:

```php
function createCustomer(CreateCustomerCommand $command): void
{
    $customer = new Customer($command->id, $command->name, $command->lastName, $command->email);
    // ...
}
```

Este refactor se llama _Introduce Parameter Object_, y es una forma de agrupar los parámetros que pasamos a una función en un objeto que agrupa los datos. Una de las ventajas es que cada dato está identificado por el nombre de la propiedad, lo que hace que sea más fácil de entender qué datos se están pasando a la función y no tener preocuparnos de hacerlo en el orden correcto.

```php
$pepaCustomer = new CreateCustomerCommand();

$pepaCustomer->id = "123";
$pepaCustomer->name = "Pepa";
$pepaCustomer->lastName = "Pérez García";
$pepaCustomer->email = "pepa@example.com";

createCustomer($pepaCustomer);
```

## Tipos

Cuando el sistema de tipos del lenguaje no nos proporciona suficientes garantías, o bien cuando consideramos ciertas restricciones que debemos aplicar frecuentemente, podemos introducir objetos que, sin llegar a representar conceptos de un dominio, nos permiten encapsular ciertas reglas genéricas.

Por ejemplo, imaginemos que queremos representar un número entero que no puede ser negativo. Podríamos hacer algo así:

```php
class NonNegative
{
    private int $value;

    public function __construct(int $value)
    {
        if ($value < 0) {
            throw new InvalidArgumentException('Value must be non-negative');
        }
        $this->value = $value;
    }

    public function __toString(): string
    {
        return (string) $this->value;
    }
}
```

De este modo, si necesitamos un número no negativo, simplemente creamos un objeto `NonNegative` y ya tenemos la garantía de que el valor será correcto. Algo similar si lo que necesitamos es strings no vacíos, que sería un requisito habitual para muchos campos de texto:

```php
class NonEmptyString
{
    private string $value;

    public function __construct(string $value)
    {
        if ('' === $value) {
            throw new InvalidArgumentException('Value must be non-empty');
        }
        $this->value = $value;
    }

    public function __toString(): string
    {
        return $this->value;
    }
}
```

Ahora, podríamos definir un objeto de dominio que represente un `Customer` de la siguiente manera, de tal modo que garantizamos que los datos que contiene son válidos:

```php
class Customer
{
    private string $id;
    private NonEmptyString $personName;
    private NonNegative $age;

    public function __construct(string $id, string $personName, int $age)
    {
        $this->id = $id;
        $this->personName = new NonEmptyString($personName);
        $this->age = new NonNegative($age);
    }
}
```

Un efecto secundario beneficioso es que leyendo la definición de `Customer` podemos visualizar también las reglas de validación estructural que se le aplican.

Una observación muy importante es que estos objetos no deben usarse como clases base para derivar _Value Objects_. No tienen un significado en el dominio, sino que son simplemente objetos que encapsulan ciertas reglas. Los usaremos siempre por composición, como si fuesen tipos nativos.

### Enumerables

Es bastante frecuente encontrarnos con ciertos conceptos que se pueden representar con un número finito, reducido y fijo, de valores posibles. Por ejemplo, el estado de un pedido, que puede ser `PENDING`, `SHIPPED`, `DELIVERED`, etc. O bien, el tipo de un producto, que puede ser `PHYSICAL`, `DIGITAL`, `SERVICE`, etc. Y también es el caso de las opciones de un menú, categorías de clasificación, y un largo etcétera.

Cuando no es previsible que estos valores cambien podemos representarlos con un tipo _Enumerable_. En pocas palabras, un tipo _Enumerable_ es aquel que tiene un número finito y fijo de valores posibles. Por tanto, para instanciar un objeto pasamos el valor y lo validamos contra los valores posibles.

```php
class OrderStatus
{
    private const PENDING = 'PENDING';
    private const SHIPPED = 'SHIPPED';
    private const DELIVERED = 'DELIVERED';

    private string $status;

    public function __construct(string $status)
    {
        if (!in_array($status, [self::PENDING, self::SHIPPED, self::DELIVERED])) {
            throw new InvalidArgumentException('Invalid status');
        }
        $this->status = $status;
    }

    public function __toString(): string
    {
        return $this->status;
    }
}
```

Esto nos permite tener la seguridad de que el estado de un pedido siempre será uno de los valores posibles. Además, si necesitamos añadir un nuevo estado, solo tendremos que modificar la clase `OrderStatus`.

Ahora bien, esto se refiere a la etiqueta o valor que representa el estado, sobre todo en lo que se refiere a contextos en los que vamos a serializar o deserializar estos valores. 

En muchos casos, necesitaremos también un comportamiento asociado, como sería el caso de un `OrderStatus` que nos permita saber si un pedido está pendiente, enviado o entregado, para determinar si podemos hacer progresar ese pedido a una nueva fase. Lo habitual es consultar de qué estado se trata para decidir qué hacer a continuación. Entonces, lo que necesitamos es un objeto que encapsule el estado y el comportamiento asociado, lo que se conoce como patrón _State_, del cual hablaremos extensamente en el capítulo correspondiente.

La línea que separa el uso de un tipo _Enumerable_ y un objeto _State_ es bastante difusa, y en muchos casos se solapan. En general, si necesitamos un objeto que represente un estado y tenga comportamiento asociado, lo que necesitamos es un patrón _State_, representando los distintos estados no ya como valores, sino como objetos. Si solo necesitamos representar un valor que puede ser uno de varios posibles, usaremos un tipo _Enumerable_.

Por supuesto, en el contexto del patrón _State_, podemos representar esos posibles valores en forma de Enumerable, al menos de cara a serializar o deserializar, a fin de obtener valores consistentes o reconstruir el objeto original.

## Objetos

Si bien los tipos no dejan de ser objetos, aquí pondremos el acento en aquellos que representan conceptos significativos en el dominio. Nos vienen a la cabeza, un `Customer` o un `Product`, que son habituales en muchos negocios, pero también podemos representar mediante objetos un `File`, una `Configuration`, un `Mapper` y, en general, cualquier concepto dentro de un programa que se pueda tratar como una unidad capaz de exponer comportamiento.

He aquí un ejemplo simple: un objeto `File` que abstrae la capacidad de escribir y leer el contenido de archivos en el sistema de archivos local. Este objeto encapsula la lógica de lectura y escritura, y nos permite trabajar con archivos de una forma más sencilla, segura y consistente.

```php
class File
{
    private string $filePath;

    public function __construct(string $filePath)
    {
        $this->filePath = $filePath;
    }

    public function read(): string
    {
        if (!file_exists($this->filePath)) {
            throw new \RuntimeException("File not found: {$this->filePath}");
        }

        $contents = file_get_contents($this->filePath);
        if ($contents === false) {
            throw new \RuntimeException("Failed to read file: {$this->filePath}");
        }

        return $contents;
    }

    public function write(string $contents): void
    {
        $result = file_put_contents($this->filePath, $contents);
        if ($result === false) {
            throw new \RuntimeException("Failed to write to file: {$this->filePath}");
        }
    }
}
```

## Value Objects

Los _value objects_ son un tipo de objetos que representan algún concepto importante en el dominio de negocio de la aplicación. En resumen, los _value objects_:

* Representan conceptos importantes o interesantes del dominio, entendido como el dominio de conocimiento que toca el código que estamos implementando o estudiando.
* Siempre son creados consistentes, de modo que si obtienes una instancia puedes tener la seguridad de que es válida. De otro modo, no se crean y se lanza una excepción.
* Los objetos nos interesan por su valor, no por su identidad, por lo que tienen que tener alguna forma de chequear su igualdad.
* Son inmutables: su valor no puede cambiar durante su ciclo de vida. En caso de que tengan métodos *mutators*, estos devolverán una nueva instancia de la clase con el valor modificado.
* Encapsulan comportamientos. Los buenos _value objects_ atraen y encapsulan comportamientos que pueden ser utilizados por el resto del código.

Los _value objects_ pueden ser genéricos y reutilizables, como `Money`, o muy específicos de un dominio.

Una aclaración que me gustaría hacer es _value object_ es uno de los bloques de construcción en _Domain Driven Design_, pero el patrón de encapsular valores primitivos en objetos lo podemos, y debemos, aplicar en cualquier tipo de diseño orientado a objetos.          

### Refactorizar a _value objects_

Refactorizar a _value objects_ puede ser una tarea de bastante calado, ya que implica crear nuevas clases y utilizarlas en diversos puntos del código. Ahora bien, este proceso puede hacerse de forma bastante gradual. Ten en cuenta que:

* Los _value objects_ no tienen dependencias, para crearlos solo necesitas primitivos o bien otros _value objects_.
* Los _value objects_ se pueden instanciar allí donde los necesites, son *newables*.
* Normalmente, tendrás métodos para convertir los _value objects_ a escalares, de modo que puedas utilizar sus valores con código que no puedes modificar.

Los _value objects_ aportan varias ventajas:

* Al encapsular su validación tendrás objetos con valores adecuados que puedes usar libremente sin necesidad de validar constantemente.
* Aportarán significado a tu código, siempre sabrás cuando una variable es un precio, un email, una edad, lo que necesites.
* Te permiten abstraerte de cuestiones como formato, precisión, etc.

## Un ejercicio para aprender a usar objetos

Veamos un objeto típico de cualquier negocio: `Customer` que da lugar a varios ejemplos clásicos de _value object_. Un cliente siempre suele tener un nombre, que acostumbra a ser una combinación de nombre de pila y uno o más apellidos. También tiene una dirección, que es una combinación de unos cuantos datos.

El siguiente ejercicio que vamos a hacer se inspira en una regla de _Object Calisthenics_, que nos pide que una clase no tenga más de dos propiedades. Hacer este ejercicio te ayudará a identificar conceptos compuestos en tus objetos. En este caso, vamos a ver cómo podemos aplicar esta regla a un objeto `Customer` que ahora mismo tiene muchas propiedades:

```php
class Customer
{
    private $id;
    private $name;
    private $firstSurname;
    private $lastSurname;
    private $street;
    private $streetNumber;
    private $floor;
    private $postalCode;
    private $city;
}
```

El constructor de nuestro `Customer` podría ser muy complicado, y eso que no hemos incluido todos los campos:

```php
class Customer
{
    private $id;
    private $name;
    private $firstSurname;
    private $lastSurname;
    private $street;
    private $streetNumber;
    private $floor;
    private $postalCode;
    private $city;

    public function __construct(
        string $id,
        string $name,
        string $firstSurname,
        ?string $lastSurname,
        string $street,
        string $streetNumber,
        string $floor,
        string $postalCode,
        string $city
    )
    {
        $this->id = $id;
        $this->name = $name;
        $this->firstSurname = $firstSurname;
        $this->lastSurname = $lastSurname;
        $this->street = $street;
        $this->streetNumber = $streetNumber;
        $this->floor = $floor;
        $this->postalCode = $postalCode;
        $this->city = $city;
    }

    public function fullName(): string 
    {
        $fullName = $this->name . ' ' . $this->firstSurname;
        
        if ($this->lastSurname) {
            $fullName .= ' ' . $this->lastSurname;
        }
        
        return $fullName;
    }

    public function address(): string 
    {
        $address = $this->street . ', ' . $this->streetNumber;
        
        if ($this->floor) {
            $address .= ' '. $this->floor;
        }
        
        $address .= $this->postalCode. '-'.$this->city;
        
        return $address;
    }
}
```

Solemos decir que las cosas que cambian juntas deben ir juntas, pero eso también implica que las cosas que no cambian juntas deberían estar separadas. En el constructor van todos los detalles mezclados y se hace muy difícil de manejar. De hecho, como prácticamente todos los campos son del mismo tipo, es fácil confundirlos. Un error en el orden de los parámetros puede ser muy difícil de detectar.

Una forma de abordar esto es introducir un patrón _Builder_:

```php
class CustomerBuilder
{
    private $name;
    private $firstSurname;
    private $lastSurname;
    private $street;
    private $streetNumber;
    private $floor;
    private $postalCode;
    private $city;

    public function withName(string $name, string $firstSurname, ?string $lastSurname) : self
    {
        $this->name = $name;
        $this->firstSurname = $firstSurname;
        $this->lastSurname = $lastSurname;
        
        return $this;
    }

    public function withAddress(string $street, string $streetNumber, string $floor, string $postalCode, string $city): self
    {
        $this->street = $street;
        $this->streetNumber = $streetNumber;
        $this->floor = $floor;
        $this->postalCode = $postalCode;
        $this->city = $city;
        
        return $this;
    }

    public function build() : Customer
    {
        return new Customer(
            $this->id,
            $this->name,
            $this->firstSurname,
            $this->lastSurname,
            $this->street,
            $this->streetNumber,
            $this->floor,
            $this->postalCode,
            $this->city
        );
    }
}
```

La ventaja del patrón _Builder_ es que nos permite ocultar la complejidad del constructor canónico, introduciendo una interfaz de construcción más significativa. Observa el siguiente código. El resultado es el mismo, pero la forma de construir el objeto es mucho más clara, y eso que la dirección se las trae, con ni más ni menos que cinco campos:

```php
$customerBuilder = new CustomerBuilder();

$customer = $customerBuilder
    ->withName('Fran', 'Iglesias', 'Gómez')
    ->withAddress('Piruleta St', '123', '4', '08030', 'Barcelona')
    ->build();
```

Pero, por otro lado, gracias a usar el _builder_ podemos ver que existen, al menos, dos conceptos: el nombre del cliente y su dirección. De hecho, en la dirección tendríamos también dos conceptos: la localidad y las señas dentro de esa localidad. En realidad tenemos casos de _Data Clump_ que podríamos resolver con objetos.

Vamos por partes:

### Introduciendo objetos

Parece que no, pero manejamos mucha lógica en algo tan simple como un nombre. Veamos por ejemplo:

* En España usamos nombres con dos apellidos, pero en muchos otros países se suele usar un nombre con un único apellido.
* A veces necesitamos usar partes del nombre por separado, como sería el nombre de pila ("Estimada Susana", "Sr. Pérez"). Otras veces queremos combinarlo de diferentes formas, como podría ser poner el apellido primero, lo que es útil para listados.
* Y, ¿qué pasa si queremos introducir nueva información relacionada con el nombre? Por ejemplo, el tratamiento (Sr./Sra., Estimado/Estimada, etc.).

El nombre del cliente se puede convertir fácilmente a un objeto, lo que retirará cualquier lógica de la "gestión" del nombre de la clase `Customer`, contribuyendo al _Single Responsibility Principle_ y proporcionándonos un comportamiento reutilizable.

Así que podemos crear un objeto sencillo:

```php
class PersonName
{
    private string $name;
    private string $firstSurname;
    private string $lastSurname;

    public function __construct(string $name, string $firstSurname, string $lastSurname)
    {
        $this->name = $name;
        $this->firstSurname = $firstSurname;
        $this->lastSurname = $lastSurname;
    }
}
```

Ahora bien, una persona tiene que tener un nombre, no tiene sentido tener objetos `PersonName` que estén vacíos. Para nuestro ejemplo, las reglas son que Name y FirstSurname son obligatorios y no pueden ser un string vacío. LastSurname es opcional.

Una forma bastante bonita de hacer esto es hacer uso de tipos como `NonEmptyString` y `String`.

```php
class NonEmptyString
{
    private string $value;

    public function __construct(string $value)
    {
        if ('' === $value) {
            throw new InvalidArgumentException('Value must be non-empty');
        }
        $this->value = $value;
    }

    public function __toString(): string
    {
        return $this->value;
    }
}
```

```php
class String
{
    private string $value;

    public function __construct(string $value)
    {
        $this->value = $value;
    }

    public function __toString(): string
    {
        return $this->value;
    }
}
```

Así que lo podemos representar de la siguiente forma:

```php
class PersonName
{
    private NonEmptyString $name;
    private NonEmptyString $firstSurname;
    private String $lastSurname;

    public function __construct(string $name, string $firstSurname, ?string $lastSurname = null)
    {
        $this->name = new NonEmptyString($name);
        $this->firstSurname = new NonEmptyString($firstSurname);
        $this->lastSurname = new String($lastSurname);
    }
}
```
Por si te lo estabas preguntando, realmente no puedo considerar seriamente `PersonName` como un value object. No tiene comportamiento de negocio relevante. Quiero decir, es importante gestionar bien el nombre de las personas, pero seguramente no forma parte de la lógica de negocio de tu aplicación. En cualquier caso, es un buen ejemplo para aprender a trabajar con objetos.

Más adelante volveremos sobre este objeto. Ahora vamos a definir varios _value objects_. De momento, solo me voy a concentrar en los constructores, sin añadir ningún comportamiento, ni siquiera el método `equals` ya que quiere centrarme en cómo movernos de usar escalares a estos objetos.

### Objetos compuestos de otros objetos

Para tratas las direcciones postales haremos algo parecido y crearemos una clase `Address` para representar las direcciones de los clientes.

Sin embargo, hemos dicho que podríamos introducir un objeto para el concepto de localidad, que incluiría el código postal y la ciudad, pues son datos que van estrechamente relacionados. Obviamente, esto dependerá de nuestro dominio. En algunos casos no nos hará falta esa granularidad porque simplemente queremos disponer de una dirección postal de nuestros clientes para enviar comunicaciones. Pero en otros casos puede ocurrir que nuestro negocio tenga aspectos que dependan de ese concepto, como un servicio cuya tarifa sea función de la ubicación.

```php
class Locality
{
    private string $postalCode;
    private string $locality;

    public function __construct(string $postalCode, string $locality)
    {
        $this->isValidPostalCode($postalCode);
        $this->isValidLocality($locality);
        
        $this->postalCode = $postalCode;
        $this->locality = $locality;
    }

    private function isValidPostalCode(string $postalCode) : void
    {
        if (\strlen($postalCode) !== 5 || (int) substr($postalCode, 0, 2) > 52) {
            throw new InvalidArgumentException('Invalid Postal Code');
        }
    }
    
    private function isValidLocality(string $locality) : void
    {
        if ($locality === '') {
            throw new InvalidArgumentException('Locality should have a value');
        }
    }

```

Como se puede ver, tendría sentido introducir un objeto `PostalCode`, porque tiene unas reglas específicas de validación. En este caso, el código postal debe tener 5 caracteres y los dos primeros no pueden ser mayores de 52, que es el número de provincias en España:

```php
class PostalCode
{
    private string $postalCode;

    public function __construct(string $postalCode)
    {
        $this->isValidPostalCode($postalCode);

        $this->postalCode = $postalCode;
    }

    private function isValidPostalCode(string $postalCode) : void
    {
        if (\strlen($postalCode) !== 5 || (int) substr($postalCode, 0, 2) > 52) {
            throw new InvalidArgumentException('Invalid Postal Code');
        }
    }
}
```

Aparte de eso, debería haber un nombre de localidad, por lo que`Locality` podría quedar así:

```php
class Locality
{
    private PostalCode $postalCode;
    private NonEmptyString $locality;

    public function __construct(string $postalCode, string $locality)
    {
        $this->postalCode = new PostalCode($postalCode);
        $this->locality = new NonEmptyString($locality);
    }
}
```

En fin. Volviendo a nuestro problema original de crear un objeto `Address` podríamos adoptar este enfoque:

```php
class Address
{
    private string $street;
    private string $streetNumber;
    private string $floor;
    private Locality $locality;

    public function __construct(string $street, string $streetNumber, ?string $floor, Locality $locality)
    {
        if ('' === $street || '' === $streetNumber) {
            throw new InvalidArgumentException('Address should include street and number');   
        } 
        $this->street = $street;
        $this->streetNumber = $streetNumber;
        $this->floor = $floor;
        $this->locality = $locality;
    }
}
```

Pero como antes hemos definido tipos que nos proporcionan ciertas garantías:

```php
class Address
{
    private NonEmptyString $street;
    private NonEmptyString $streetNumber;
    private String $floor;
    private Locality $locality;

    public function __construct(string $street, string $streetNumber, ?string $floor, Locality $locality)
    {
        $this->street = new NonEmptyString($street);
        $this->streetNumber = new NonEmptyString($streetNumber);
        $this->floor = new String($floor);
        $this->locality = $locality;
    }
}
```

Siempre que un objeto requiere muchos parámetros en su construcción puede ser interesante plantearse si tenemos buenas razones para organizarlos en un objeto, aplicando el principio de co-variación: si cambian juntos, deberían ir juntos. En este caso, `$street`, `$streetNumber` y `$floor` pueden ir juntos, en forma de `StreetAddress` porque entre los tres componen un concepto útil.

```php
class StreetAddress
{
    private NonEmptyString $street;
    private NonEmptyString $streetNumber;
    private String $floor;

    public function __construct(string $street, string $streetNumber, ?string $floor)
    {
        $this->street = new NonEmptyString($street);
        $this->streetNumber = new NonEmptyString($streetNumber);
        $this->floor = new String($floor);
    }
}
```

De este modo, `Address` se hace más simple y ni siquiera tiene que ocuparse de validar nada:

```php
class Address
{
    private StreetAddress $streetAddress;
    private Locality $locality;

    public function __construct(StreetAddress $streetAddress, Locality $locality)
    {
        $this->streetAddress = $streetAddress;
        $this->locality = $locality;
    }
}
```

En resumidas cuentas, a medida que reflexionamos sobre los conceptos del dominio podemos percibir la necesidad de trasladar esa reflexión al código de una forma más articulada y precisa. Pero como hemos señalado antes todo depende de las necesidades de nuestro dominio. Lo cierto es que, como veremos a lo largo del artículo, cuanto más articulado tengamos el dominio, vamos a tener más capacidad de maniobra y muchísima más coherencia.

### Usando los objetos

Volvamos a `Customer`. De momento, el hecho de introducir una serie de _objetos_ no afecta para nada al código que tengamos, por lo que podríamos estar creando cada uno de ellos, mezclando en el proyecto y desplegando sin afectar de ningún modo a la funcionalidad existente. Simplemente, hemos añadido clases a nuestra base de código y ahí están: esperando a ser utilizadas.

En este caso, tener a `CustomerBuilder` nos viene muy bien, pues encapsula la compleja construcción de `Customer`, aislándola del resto del código. Podremos refactorizar `Customer` sin afectar a nadie. Empezaremos por el nombre:

```php
class Customer
{
    private string $id;
    private PersonName $personName;
    private string $street;
    private string $streetNumber;
    private string $floor;
    private string $postalCode;
    private string $city;

    public function __construct(
        string $id,
        PersonName $personName,
        string $street,
        string $streetNumber,
        string $floor,
        string $postalCode,
        string $city
    ) {
        $this->id = $id;
        $this->personName = $personName;
        $this->street = $street;
        $this->streetNumber = $streetNumber;
        $this->floor = $floor;
        $this->postalCode = $postalCode;
        $this->city = $city;
    }

    public function fullName(): string
    {
        return $this->personName->fullName();
    }

    public function address(): string
    {
        $address = $this->street . ', ' . $this->streetNumber;

        if ($this->floor) {
            $address .= ' '. $this->floor;
        }

        $address .= $this->postalCode. '-'.$this->city;

        return $address;
    }
}
```

El constructor ya es un poco más simple. Además, el método `fullName` puede delegarse al disponible en el objeto `PersonName`, que se puede ocupar cómodamente de cualquier variante o formato particular que necesitemos a lo largo de la aplicación.

```php
class PersonName
{
    private NonEmptyString $name;
    private NonEmptyString $firstSurname;
    private String $lastSurname;

    public function __construct(string $name, string $firstSurname, ?string $lastSurname = null)
    {
        $this->name = new NonEmptyString($name);
        $this->firstSurname = new NonEmptyString($firstSurname);
        $this->lastSurname = new String($lastSurname);
    }

    public function fullName(): string
    {
        $fullName = (string)$this->name . ' ' . (string)$this->firstSurname;
        
        if (!$this->lastSurname->empty() {
            $fullName .= ' ' . $this->lastSurname;
        }
        
        return $fullName;
    }
}
```

Como podemos ver, los objetos atraen comportamiento. Si necesitásemos el nombre en un formato apto para listas podríamos hacer lo siguiente:

```php
class PersonName
{
    private NonEmptyString $name;
    private NonEmptyString $firstSurname;
    private String $lastSurname;

    public function __construct(string $name, string $firstSurname, ?string $lastSurname = null)
    {
        $this->name = new NonEmptyString($name);
        $this->firstSurname = new NonEmptyString($firstSurname);
        $this->lastSurname = new String($lastSurname);
    }

    public function fullName(): string
    {
        return (string)$this->name .' ' . $this->surname();
    }

    public function listName(): string
    {
        return $this->surname() . ', ' . (string)$this->name;
    }

    public function surname(): string
    {
        $surname = (string)$this->firstSurname;

        if (!$this->lastSurname->empty()) {
            $surname .= ' ' . $this->lastSurname;
        }

        return $surname;
    }
}
```

Como tenemos un Builder que encapsula la construcción de `Customer`, lo que hacemos es modificar esa construcción de acuerdo al nuevo diseño:

```php
class CustomerBuilder
{
    private string $id;
    private PersonName $personName;
    private string $street;
    private string $streetNumber;
    private string $floor;
    private string $postalCode;
    private string $city;

    public function withName(string $name, string $firstSurname, ?string $lastSurname) : self
    {
        $this->personName = new PersonName($name, $firstSurname, $lastSurname);
        
        return $this;
    }

    public function withAddress(string $street, string $streetNumber, string $floor, string $postalCode, string $city): self
    {
        $this->street = $street;
        $this->streetNumber = $streetNumber;
        $this->floor = $floor;
        $this->postalCode = $postalCode;
        $this->city = $city;
        
        return $this;
    }

    public function build() : Customer
    {
        return new Customer(
            $this->id,
            $this->personName,
            $this->street,
            $this->streetNumber,
            $this->floor,
            $this->postalCode,
            $this->city
        );
    }
}
```

Fíjate que he dejado el método `withName()` tal y como estaba. De esta forma, no cambio la interfaz pública de `CustomerBuilder`, como tampoco cambia la de `Customer` salvo en el constructor, y el código que lo usa no se enterará del cambio. En otras palabras, el ejemplo anterior funcionará exactamente igual:

```php
$customerBuilder = new CustomerBuilder();

$customer = $customerBuilder
    ->withName('Fran', 'Iglesias', 'Gómez')
    ->withAddress('Piruleta St', '123', '4', '08030', 'Barcelona')
    ->build();
```

Por supuesto, haríamos lo mismo con el objeto `Address`. Por tanto, así quedará `Customer`:

```php
class Customer
{
    private $id;
    private PersonName $personName;
    private Address $address;

    public function __construct(
        string $id,
        PersonName $personName,
        Address $address
    ) {
        $this->id = $id;
        $this->personName = $personName;
        $this->address = $address;
    }

    public function fullName(): string
    {
        return $this->personName->fullName();
    }

    public function address(): string
    {
        return $this->address->full();
    }
}
```

El método `full` en `Address` queda como sigue:

```php
class Address
{
    private StreetAddress $streetAddress;
    private Locality $locality;

    public function __construct(StreetAddress $streetAddress, Locality $locality)
    {
        $this->streetAddress = $streetAddress;
        $this->locality = $locality;
    }

    public function full(): string
    {
        return (string)$this->streetAddress . ' ' . (string)$this->locality;
    }
}
```

En este caso necesitaremos:

```php
class StreetAddress
{

    private NonEmptyString $street;
    private NonEmptyString $streetNumber;
    private String $floor;

    public function __construct(string $street, string $streetNumber, ?string $floor)
    {
        $this->street = new NonEmptyString($street);
        $this->streetNumber = new NonEmptyString($streetNumber);
        $this->floor = new String($floor);
    }

    public function __toString(): string 
    {
        $fullAddress = (string)$this->street . ' ' . (string)$this->streetNumber;
        
        if (!$this->floor->empty()) {
            $fullAddress .= ', '. $this->floor;
        }
        
        return $fullAddress;
    }
}
```

Y también:

```php
class PostalCode
{
    private string $postalCode;

    public function __construct(string $postalCode)
    {
        $this->isValidPostalCode($postalCode);

        $this->postalCode = $postalCode;
    }

    private function isValidPostalCode(string $postalCode) : void
    {
        if (\strlen($postalCode) !== 5 || (int) substr($postalCode, 0, 2) > 52) {
            throw new InvalidArgumentException('Invalid Postal Code');
        }
    }

    public function __toString(): string 
    {
        return $this->postalCode;
    }
}
```

Así como:

```php
class Locality
{
    private PostalCode $postalCode;
    private NonEmptyString $locality;

    public function __construct(string $postalCode, string $locality)
    {
        $this->postalCode = new PostalCode($postalCode);
        $this->locality = new NonEmptyString($locality);
    }

    public function __toString(): string 
    {
        return (string)$this->postalCode .'-'.(string)$this->locality;
    }
}
```

Del mismo modo que antes, modificaremos `CustomerBuilder` para utilizar los nuevos objetos:

```php
class CustomerBuilder
{
    private $personName;
    private $address;

    public function withName(string $name, string $firstSurname, ?string $lastSurname) : self
    {
        $this->personName = new PersonName($name, $firstSurname, $lastSurname);
        
        return $this;
    }

    public function withAddress(string $street, string $streetNumber, string $floor, string $postalCode, string $city) : self
    {
        $locality = new Locality($postalCode, $city);
        $streetAddress = new StreetAddress($street, $streetNumber, $floor);

        $this->address = new Address($streetAddress, $locality);
        
        return $this;
    }

    public function build() : Customer
    {
        return new Customer(
            $this->id,
            $this->personName,
            $this->address
        );
    }
}
```

Y ya está, hemos hecho este cambio sin tener que tocar en ningún lugar más del código. Obviamente, tener un _Builder_ de `Customer` nos ha facilitado muchos las cosas. En general, para hacer este tipo de refactorizaciones, es útil tener alternativas al constructor canónico, como el propio _Builder_.

### Beneficios

El beneficio más evidente es que las clases importantes del dominio como `Customer`, quedan mucho más compactas. Hemos podido reducir ocho propiedades a dos, cumpliendo la regla de _Calisthenics_. Y, además, son conceptos relevantes dentro de `Customer`.

Por otro lado, `Customer` delega todos los detalles a esos objetos. Dicho de otro modo, `Customer` no tiene que saber cómo se da formato a un nombre o a una dirección. Simplemente, cuando se lo piden entrega el nombre o la dirección formateados. Asimismo, cualquier otro objeto que usase `PersonName` o `Address`, lo hará de la misma manera.

Otra cosa interesante es que los cambios que necesitemos en el comportamiento de estas propiedades pueden aplicarse sin tocar el código de la clase, modificando o cambiando los objetos, con lo cual el nuevo comportamiento se extenderá a todas las partes de la aplicación que lo utilicen.

Sin embargo, nuestro dominio tiene ahora muchísima flexibilidad y capacidad de cambio. 

Sería bastante fácil, por ejemplo, dar soporte a los múltiples formatos de dirección postal que se usan en todo el mundo, de modo que nuestro negocio está mejor preparado para expandirse internacionalmente, puesto que solo tendríamos que introducir una interfaz y nuevos formatos a medida que los necesitemos, sin tener que cambiar el `core` del dominio. Puede sonar exagerado, pero estos pequeños detalles pueden ser un dolor de cabeza enorme si seguimos el modelo con el que empezamos. Algo tan pequeño puede ser la diferencia entre un código y un negocio que escale fácilmente o no.

## Resumen del capítulo

Encapsular tipos primitivos en objetos es una receta de éxito para lograr código más simple y, a la vez, ganar en consistencia y flexibilidad. El código tiene que preocuparse menos por conocer el detalle de los datos, centrándose en cómo interactúan los objetos y colaboran entre ellos para lograr el propósito de la aplicación.
